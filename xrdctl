#!/usr/bin/env bash

if test -t 1; then
    ncolors=$(tput colors)
    if test -n "${ncolors}" && test "${ncolors}" -ge 8; then
        BOLD="$(tput bold)"
        UNDERLINE="$(tput smul)"
        NORMAL="$(tput sgr0)"
        RED="$(tput setaf 1)"
        GREEN="$(tput setaf 2)"
        YELLOW="$(tput setaf 3)"
    fi
fi

command -v curl &> /dev/null || { echo "curl command not found; do : yum -y install curl.x86_64"; exit 1; }
command -v bzip2 &> /dev/null || { echo "bzip2 command not found (logs compression); do : yum -y install bzip2.x86_64"; exit 1; }
command -v pgrep &> /dev/null || { echo "pgrep command not found; do : yum -y install procps-ng.x86_64"; exit 1; }
command -v awk &> /dev/null || { echo "pgrep command not found; do : yum -y install awk"; exit 1; }

######################################
OK="[  ${GREEN}OK${NORMAL}  ]"
FAILURE="[  ${RED}DOWN${NORMAL}  ]"
WARNING="[  ${YELLOW}PASSED${NORMAL}  ]"

######################################
removecron() {
    local cron_file CFG
    CFG="${2}"
    cron_file="/tmp/cron.$RANDOM.xrd.sh";
    /usr/bin/crontab -l | sed "/\s*#.*/! { /xrdctl.*${CFG}/ d}" > ${cron_file}; # get current crontab and delete uncommented xrdctl lines
    /usr/bin/crontab ${cron_file}; # put back the cron without xrd.sh
    /bin/rm -f ${cron_file};
}

######################################
addcron() {
    local RUNDIR CFG
    RUNDIR="${1}"
    [[ -z "${RUNDIR}" ]] && return 1;
    CFG="${2}"

    removecron "${CFG}"  # clean up the old xrd.sh cron line
    cron_file="/tmp/cron.${RANDOM}.xrd.sh";
    /usr/bin/crontab -l > "${cron_file}"; # get current crontab

    ## add to cron_file the xrd.sh command
    echo -ne "\
*/5 * * * * BASH_ENV=$HOME/.bash_profile ${XRDSHDIR}/xrdctl -c    ${CFG} >> ${RUNDIR}/logs/xrd.watchdog.log 2>&1\\n
0   3 * * * BASH_ENV=$HOME/.bash_profile ${XRDSHDIR}/xrdctl -logs ${CFG} >> ${RUNDIR}/logs/xrd.watchdog.log 2>&1\\n
@reboot     BASH_ENV=$HOME/.bash_profile ${XRDSHDIR}/xrdctl -c    ${CFG} >> ${RUNDIR}/logs/xrd.watchdog.log 2>&1\\n" >> ${cron_file}

    /usr/bin/crontab "${cron_file}"; # put back the cron with xrd.sh
    /usr/bin/crontab -l | /usr/bin/sed '/^$/d;s/[[:blank:]]//g' | /usr/bin/crontab # clean up any whitespaces
    /bin/rm -f "${cron_file}";
}

######################################
handlelogs() {
    [[ -z "${XRDRUNDIR}" ]] && return 1;
    cd "${XRDRUNDIR}" || { echo "XRDRUNDIR not found"; return 1; }
    cd "${XRDRUNDIR}/logs" || { echo "{XRDRUNDIR}/logs not found"; return 1; }

    /bin/mkdir -p "${XRDRUNDIR}/logsbackup"
    local LOCK
    LOCK="${XRDRUNDIR}/logs/HANDLELOGS.lock"
    #local todaynow=$(date +%Y%m%d_%k%M%S)
    not_compressed=$(/bin/find . -type f \
            -not -name '*.lock' -not -name '*.bz2' -not -name 'stage_log' \
            -not -name 'cmslog' -not -name 'xrdlog' -not -name 'pstg_log' \
            -not -name 'xrd.watchdog.log' -not -name 'apmon.log' -not -name 'servMon.log' -print)

    if [[ ! -f "${LOCK}" ]]; then
        touch "${LOCK}"
        for log in ${not_compressed}; do
            /usr/bin/bzip2 -9fq "${log}";
        done
        /bin/rm -f "${LOCK}"
    fi
    # move compressed to logs backup
    find "${XRDRUNDIR}/logs/" -type f -name "*log.*.bz2" -exec mv '{}' "${XRDRUNDIR}/logsbackup/" \; &> /dev/null
}

######################################
help () {
echo "usage: ${0} arg [configuration_file]
where argument is _one_ of :
[-f|--f|-restart|--restart] force restart
[-c|--c|-check|--check] check and restart if not running
[-k|--k|-kill|--kill] kill running processes
[-s|--s|-status|--status] show status of services
[-logs|--logs] manage the logs
[-addcron|--addcron] add/refresh cron line

Environment variables:
XRDRUNDIR : location of admin,core,logs,logsbackup dirs; if not set it will be XRDSHDIR/run/
XRDCONFDIR : location of system.cnf and XRDCF (default xrootd.xrootd.cf) conf files; if not set it will be XRDSHDIR/xrootd.conf/
XRDCTL_DEBUG : if set (any value) it will enable various printouts of xrdctl";
}

######################################
getPidFiles () {
[[ -z "${1}" ]] && return 1;
local proc_out exitcode
proc_out=$(/usr/bin/pgrep -u "$(id -u)" -ax "${1}")
exitcode=$?
[[ -n "${proc_out}" ]] && awk '{for ( x = 1; x <= NF; x++ ) { if ($x == "-s") {print $(x+1)} }}' <<< "${proc_out}"
return ${exitcode}
}
getPidFiles_xrd () { XRDCTL_CMD_XRD=${XRDCTL_CMD_XRD:-/usr/bin/xrootd}; getPidFiles "${XRDCTL_CMD_XRD}"; return $?; }
getPidFiles_cmsd () { XRDCTL_CMD_CMSD=${XRDCTL_CMD_CMSD:-/usr/bin/cmsd}; getPidFiles "${XRDCTL_CMD_CMSD}"; return $?; }

######################################
getInstances_list () {
[[ -z "${1}" ]] && return 1;
local proc_out pid_list
proc_out=$(/usr/bin/pgrep -u "$(id -u)" -ax "${1}")
[[ -z "${proc_out}" ]] && return $?
pid_list=$(awk '{for ( x = 1; x <= NF; x++ ) { if ($x == "-n") {print $(x+1)} }}' <<< "${proc_out}") #'
[[ -z "${pid_list}" ]] && return 1;
echo "${pid_list}"
return 0;
}
getInstances_list_xrd () { XRDCTL_CMD_XRD=${XRDCTL_CMD_XRD:-/usr/bin/xrootd}; getInstance "${XRDCTL_CMD_XRD}"; return $?; }
getInstances_list_cmsd () { XRDCTL_CMD_CMSD=${XRDCTL_CMD_CMSD:-/usr/bin/cmsd}; getInstance "${XRDCTL_CMD_CMSD}"; return $?; }

######################################
getInstance_pid () {
[[ -z "${1}" || -z "${2}" ]] && return 1;
local cmd instance proc_out instance_pid
cmd="${1}"
instance="${2}"
proc_out="$(/usr/bin/pgrep -u $(id -u) -ax ${cmd})"
[[ -z "${proc_out}" ]] && return $?
instance_pid=$(awk -v name="${instance}" '{for ( x = 1; x <= NF; x++ ) { if ($x == "-n" && $(x+1) == name ) {print $1} }}' <<< "${proc_out}") #'
[[ -z "${instance_pid}" ]] && return 1;
echo "${instance_pid}"
return 0;
}
getInstance_pid_xrd () { XRDCTL_CMD_XRD=${XRDCTL_CMD_XRD:-/usr/bin/xrootd}; getInstance_pid "${XRDCTL_CMD_XRD}" "${1}"; return $?; }
getInstance_pid_cmsd () { XRDCTL_CMD_CMSD=${XRDCTL_CMD_CMSD:-/usr/bin/cmsd}; getInstance_pid "${XRDCTL_CMD_CMSD}" "${1}"; return $?; }


######################################
startXRDserv_help () {
echo 'This wrapper for starting of _xrootd_ services use the following _required_ variables defined in the configuration
__XRD_INSTANCE_NAME= name of the xrootd instance - required
__XRD_LOG= xrootd log file - required
See the documentation for detailed explanation of arguments:
http://xrootd.org/doc/dev44/xrd_config.htm#_Toc454222279
N.B.!! pid file location and admin path ar hardcoded to /tmp/xrootd_$(id -u)'
}

######################################
startCMSDserv_help () {
echo 'This wrapper for starting of _cmsd_ services use the following _required_ variables defined in the configuration
__CMSD_INSTANCE_NAME= name of the cmsd instance - required
__CMSD_LOG= cmsd log file - required
http://xrootd.org/doc/dev44/xrd_config.htm#_Toc454222279
N.B.!! pid file location and admin path ar hardcoded to /tmp/xrootd_$(id -u)'
}

######################################
status () {
local CFG
CFG="${1}"
[[ -f "${CFG}" ]] || { echo "${CFG} not found!!"; return 1; }

## get server arguments from config file.
eval "$(sed -ne 's/\#@@/local /gp;' ${CFG})"
[[ -z "${__INSTANCE_NAME}" ]] && { echo "Instance name was not defined/found in ${CFG}"; exit 1; }

local cmsd_pid cmsd_status cmsd_pid_found cmsd_pid_recorded __CMSD_PIDFILE
cmsd_pid_found=$(getInstance_pid_cmsd "${__INSTANCE_NAME}")
__CMSD_PIDFILE="/tmp/xrootd_$(id -u)/${__INSTANCE_NAME}/cmsd.pid"
[[ -e "${__CMSD_PIDFILE}" ]] && cmsd_pid_recorded=$(<"${__CMSD_PIDFILE}")
[[ -e "${__CMSD_PIDFILE}" && -z "${cmsd_pid_found}" ]] && cmsd_pidf_present_but_dead=" : cmsd pid file is present but process is not running"
[[ "${cmsd_pid_found}" -eq "${cmsd_pid_recorded}" ]] && cmsd_pid="${cmsd_pid_found}"
if [[ -n "${cmsd_pid}" ]]; then
    cmsd_status="${OK}; RSS = $(awk '/VmRSS/{printf("%.2f MiB\n",$2/1024);}' /proc/"${cmsd_pid}"/status)"
else
    cmsd_status="${FAILURE}${cmsd_pidf_present_but_dead}"
fi

local xrd_pid xrd_status xrd_pid_found xrd_pid_recorded __XRD_PIDFILE
xrd_pid_found=$(getInstance_pid_xrd "${__INSTANCE_NAME}")
__XRD_PIDFILE="/tmp/xrootd_$(id -u)/${__INSTANCE_NAME}/xrootd.pid"
[[ -e "${__XRD_PIDFILE}" ]] && xrd_pid_recorded=$(<"${__XRD_PIDFILE}")
[[ -e "${__XRD_PIDFILE}" && -z "${xrd_pid_found}" ]] && xrd_pidf_present_but_dead=" : xrootd pid file is present but process is not running"
[[ "${xrd_pid_found}" -eq "${xrd_pid_recorded}" ]] && xrd_pid="${xrd_pid_found}"
if [[ -n "${xrd_pid}" ]]; then
    xrd_status="${OK}; RSS = $(awk '/VmRSS/{printf("%.2f MiB\n",$2/1024);}' /proc/"${xrd_pid}"/status)"
else
    xrd_status="${FAILURE}${xrd_pidf_present_but_dead}"
fi

echo -e "******************************************
$(date) :: Status for instance : ${__INSTANCE_NAME}
Status CMSD :\t${cmsd_status}
Status XROOTD :\t${xrd_status}
"
[[ -z "${cmsd_pid}" || -z "${cmsd_pid}" ]] && return 1 || return 0
}

######################################
startXROOTDprocs () {
local CFG cmsd_needed cmsd_instances XRDCTL_CMD_CMSD CMSD_START xrd_instances XRDCTL_CMD_XRD XRD_START
CFG="${1}"
[[ -f "${CFG}" ]] || { echo "${CFG} not found!!"; return 1; }

## get __CMSD_ server arguments from config file.
eval "$(sed -ne 's/\#@@/local /gp;' ${CFG})"
[[ -z "${__INSTANCE_NAME}" ]] && { echo "Instance name was not defined/found in ${CFG}"; exit 1; }

cmsd_needed=$(grep 'all.role' "${CFG}")
if [[ -n "${cmsd_needed}" ]]; then
    local __CMSD_PIDFILE __CMSD_ADMINPATH
    __CMSD_PIDFILE="/tmp/xrootd_$(id -u)/${__INSTANCE_NAME}/cmsd.pid"  # it will be "fenced" by xrootd
    __CMSD_ADMINPATH="$(dirname ${__CMSD_PIDFILE})"

    ## make sure that they are defined
    # shellcheck disable=2153
    [[ -z "${__CMSD_LOG}" ]] && { startCMSDserv_help; exit 1; }

    ## not matter how is enabled the debug mode means -d
    [[ -n "${__CMSD_DEBUG}" ]] && __CMSD_DEBUG="-d"

    ## make sure that no services with the same instance name are started
    cmsd_instances=$(getInstance_pid_cmsd "${__INSTANCE_NAME}")
    [[ ${cmsd_instances}  =~ ${__INSTANCE_NAME} ]] && { echo "startXROOTDprocs :: >>>>>> FOUND CMSD SERVICE WITH THE SAME INSTANCE NAME: ${cmsd_instances}/${__INSTANCE_NAME}! <<<<<<<"; return 1; }

    XRDCTL_CMD_CMSD=${XRDCTL_CMD_CMSD:-/usr/bin/cmsd}
    [[ -n "${XRDCTL_PRELOAD}" ]] && XRDCTL_CMD_CMSD="LD_PRELOAD=${XRDCTL_PRELOAD} ${XRDCTL_CMD_CMSD}"
    CMSD_START="${XRDCTL_CMD_CMSD} -b ${__CMSD_DEBUG} -n ${__INSTANCE_NAME} -s ${__CMSD_PIDFILE} -a ${__CMSD_ADMINPATH} -w ${__CMSD_ADMINPATH} -l ${__CMSD_LOG} -c ${CFG}"

    # start the service
    ${CMSD_START}
fi

## make sure that they are defined
local __XRD_PIDFILE __XRD_ADMINPATH
__XRD_PIDFILE="/tmp/xrootd_$(id -u)/${__INSTANCE_NAME}/xrootd.pid"  # it will be "fenced" by xrootd
__XRD_ADMINPATH="$(dirname ${__XRD_PIDFILE})"

# shellcheck disable=2153
[[ -z "${__XRD_LOG}"  ]]  && { startXRDserv_help; exit 1; }

## not matter how is enabled the debug mode means -d
[[ -n "${__XRD_DEBUG}" ]] && __XRD_DEBUG="-d"

## make sure that no services with the same instance name are started
xrd_instances=$(getInstance_pid_xrd "${__INSTANCE_NAME}")
[[ ${xrd_instances} =~ ${__INSTANCE_NAME} ]] && { echo "startXROOTDprocs :: >>>>>> FOUND XROOTD SERVICE WITH THE SAME INSTANCE NAME: ${xrd_instances}/${__INSTANCE_NAME}! <<<<<<<"; return 1; }

XRDCTL_CMD_XRD=${XRDCTL_CMD_XRD:-/usr/bin/xrootd}
[[ -n "${XRDCTL_PRELOAD}" ]] && XRDCTL_CMD_XRD="LD_PRELOAD=${XRDCTL_PRELOAD} ${XRDCTL_CMD_XRD}"
XRD_START="${XRDCTL_CMD_XRD}  -b ${__XRD_DEBUG} -n ${__INSTANCE_NAME} -s ${__XRD_PIDFILE} -a ${__XRD_ADMINPATH} -w ${__XRD_ADMINPATH} -l ${__XRD_LOG} -c ${CFG}"

# start the service
${XRD_START}
}

######################################
killXROOTDprocs () {
local CFG cmsd_pid xrd_pid
CFG="${1}"
[[ -f "${CFG}" ]] || { echo "${CFG} not found!!"; return 1; }

## get __CMSD_ server arguments from config file.
eval "$(sed -ne 's/\#@@/local /gp;' ${CFG})"

cmsd_pid=$(getInstance_pid_cmsd "${__INSTANCE_NAME}")
xrd_pid=$(getInstance_pid_xrd "${__INSTANCE_NAME}")
[[ -n "${xrd_pid}" ]] && /usr/bin/kill "${xrd_pid}"
[[ -n "${cmsd_pid}" ]] && /usr/bin/kill "${cmsd_pid}"

MON_PERF=$(awk '/\s+#/ && /cms.perf/ {for ( x = 1; x <= NF; x++ ) {if ($x == "pgm") {print $(x+1)} }}' "${CFG}") #'
[[ -n "${MON_PERF}" ]] && /usr/bin/pkill -x $(basename "${MON_PERF}")
}

######################################
restartXROOTDprocs () {
local CFG
CFG="${1}"
[[ -f "${CFG}" ]] || { echo "${CFG} not found!!"; return 1; }
killXROOTDprocs "${CFG}"
startXROOTDprocs "${CFG}"
status "${CFG}"
}

######################################
checkXROOTDprocs () {
local CFG
CFG="${1}"
[[ -f "${CFG}" ]] || { echo "${CFG} not found!!"; return 1; }
status "${CFG}" &> /dev/null || { restartXROOTDprocs "${CFG}"; }
}

######################################
### START OF MAIN CODEPATH
## find the location of xrdctl script
SOURCE="${BASH_SOURCE[0]}"
while [ -h "${SOURCE}" ]; do ## resolve $SOURCE until the file is no longer a symlink
    XRDSHDIR="$( cd -P "$(dirname "${SOURCE}" )" && pwd )" ##"
    SOURCE="$(readlink "${SOURCE}")" ##"
    [[ "${SOURCE}" != /* ]] && SOURCE="${XRDSHDIR}/${SOURCE}" ## if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
XRDSHDIR="$(cd -P "$( dirname "${SOURCE}" )" && pwd)" ##"

case "${1}" in
-c|--c|-check|--check)
    DO_CHECK="1"
    shift
    ;;
-k|--k|-kill|--kill)
    DO_KILL="1"
    shift
    ;;
-f|--f|-restart|--restart)
    DO_RESTART="1"
    shift
    ;;
-s|--s|-status|--status)
    DO_STATUS="1"
    shift
    ;;
-logs|--logs)
    DO_LOGS="1"
    shift
    ;;
-crontab|--crontab)
    DO_CRONTAB="1"
    shift
    ;;
-*|--*) # unsupported flags, just catch any mistakes
    echo "Error: Unsupported flag ${1}" >&2
    exit 1
    ;;
esac

if (( "${#@}" > 1 )); then
    echo "More than 1 argument remaining, it should be at most 1";
    exit 1;
fi

## establish the configuration files to be acted upon
declare -a CONF_LIST  # container for configuration file(s)

if [[ -n "${1}" ]]; then
    CONF_ARG="$(realpath -e ${1})"

    [[ -f "${CONF_ARG}" ]] && CONF_LIST+=("${CONF_ARG}")  # is arg is file
    if [[ -d "${CONF_ARG}" ]]; then  # is arg is directory
        if [[ -n "${XRDCTL_MULTISRV}" ]]; then
            for conf_file in "${CONF_ARG}"/*.xrdcfg; do
                CONF_LIST+=("${conf_file}");
            done
        else
            CONF_LIST+=("${CONF_ARG}/xrootd.xrootd.cf")  # default filename for configuration
        fi
    fi
fi

if [[ ${#CONF_LIST[@]} -eq 0 ]]; then  # if the configuration was not specified then..
XRDRUNDIR=${XRDRUNDIR:-${XRDSHDIR}/run/}  # location of logs, admin, core dirs
XRDCONFDIR=${XRDCONFDIR:-${XRDSHDIR}/xrootd.conf/}  # location of configuration file(s)
    if [[ -n "${XRDCTL_MULTISRV}" ]]; then
        for conf_file in "${XRDCONFDIR}"/*.xrdcfg; do
            CONF_LIST+=("${conf_file}");
        done
    else
        [[ -f "${XRDCONFDIR}/xrootd.xrootd.cf" ]] && CONF_LIST+=("${XRDCONFDIR}/xrootd.xrootd.cf")
    fi
fi

[[ ${#CONF_LIST[@]} -eq 0 ]] && { echo "No configuration file found"; exit 1; }

for cfg in "${CONF_LIST[@]}" ; do
    [[ -n ${DO_CHECK} ]] && { checkXROOTDprocs "${cfg}"; continue; }
    [[ -n ${DO_KILL} ]] && { killXROOTDprocs "${cfg}"; continue; }
    [[ -n ${DO_RESTART} ]] && { restartXROOTDprocs "${cfg}"; continue; }
    [[ -n ${DO_STATUS} ]] && { status "${cfg}"; continue; }
    [[ -n ${DO_LOGS} ]] && { handlelogs "${cfg}"; continue; }
    [[ -n ${DO_CRONTAB} ]] && { addcron "${cfg}"; continue; }
done




